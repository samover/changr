// Generated by Apple Swift version 2.1.1 (swiftlang-700.1.101.15 clang-700.1.81)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if defined(__has_include) && __has_include(<uchar.h>)
# include <uchar.h>
#elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
#endif

typedef struct _NSZone NSZone;

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted) 
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
#endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#if defined(__has_feature) && __has_feature(modules)
@import UIKit;
@import ObjectiveC;
@import CoreGraphics;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@class NSCoder;

SWIFT_CLASS("_TtC16DrawerController18AnimatedMenuButton")
@interface AnimatedMenuButton : UIButton
- (nullable instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UIColor;

SWIFT_CLASS("_TtC16DrawerController19DrawerBarButtonItem")
@interface DrawerBarButtonItem : UIBarButtonItem
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithTarget:(id __nullable)target action:(SEL __null_unspecified)action;
- (nonnull instancetype)initWithTarget:(id __nullable)target action:(SEL __null_unspecified)action menuIconColor:(UIColor * __nonnull)menuIconColor;
- (nullable instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UIGestureRecognizer;
@class UITouch;
@protocol UIViewControllerTransitionCoordinator;

SWIFT_CLASS("_TtC16DrawerController16DrawerController")
@interface DrawerController : UIViewController <UIGestureRecognizerDelegate>

/// The center view controller.
///
/// This can only be set via the init methods, as well as the <code>setNewCenterViewController:...
/// </code> methods. The size of this view controller will automatically be set to the size of the drawer container view controller, and it's position is modified from within this class. Do not modify the frame externally.
@property (nonatomic, strong) UIViewController * __nullable centerViewController;

/// The left drawer view controller.
///
/// The size of this view controller is managed within this class, and is automatically set to the appropriate size based on the <code>maximumLeftDrawerWidth
/// </code>. Do not modify the frame externally.
@property (nonatomic, strong) UIViewController * __nullable leftDrawerViewController;

/// The right drawer view controller.
///
/// The size of this view controller is managed within this class, and is automatically set to the appropriate size based on the <code>maximumRightDrawerWidth
/// </code>. Do not modify the frame externally.
@property (nonatomic, strong) UIViewController * __nullable rightDrawerViewController;

/// The maximum width of the leftDrawerViewController.
///
/// By default, this is set to 280. If the <code>leftDrawerViewController
/// </code> is nil, this property will return 0.0;
@property (nonatomic) CGFloat maximumLeftDrawerWidth;

/// The maximum width of the rightDrawerViewController.
///
/// By default, this is set to 280. If the <code>rightDrawerViewController
/// </code> is nil, this property will return 0.0;
@property (nonatomic) CGFloat maximumRightDrawerWidth;

/// The visible width of the leftDrawerViewController.
///
/// Note this value can be greater than <code>maximumLeftDrawerWidth
/// </code> during the full close animation when setting a new center view controller;
@property (nonatomic, readonly) CGFloat visibleLeftDrawerWidth;

/// The visible width of the rightDrawerViewController.
///
/// Note this value can be greater than <code>maximumRightDrawerWidth
/// </code> during the full close animation when setting a new center view controller;
@property (nonatomic, readonly) CGFloat visibleRightDrawerWidth;

/// A boolean that determines whether or not the panning gesture will "hard-stop" at the maximum width for a given drawer side.
///
/// By default, this value is set to YES. Enabling <code>shouldStretchDrawer
/// </code> will give the pan a gradual asymptotic stopping point much like <code>UIScrollView
/// </code> behaves. Note that if this value is set to YES, the <code>drawerVisualStateBlock
/// </code> can be passed a <code>percentVisible
/// </code> greater than 1.0, so be sure to handle that case appropriately.
@property (nonatomic) BOOL shouldStretchDrawer;
@property (nonatomic) CGFloat drawerDampingFactor;

/// The flag determining if a shadow should be drawn off of centerViewController when a drawer is open.
///
/// By default, this is set to YES.
@property (nonatomic) BOOL showsShadows;
@property (nonatomic) CGFloat animationVelocity;

/// Sets a callback to be called when a gesture has been completed.
///
/// This block is called when a gesture action has been completed. You can query the <code>openSide
/// </code> of the <code>drawerController
/// </code> to determine what the new state of the drawer is.
///
/// \param gestureCompletionBlock A block object to be called that allows the implementer be notified when a gesture action has been completed.
@property (nonatomic, copy) void (^ __nullable gestureCompletionBlock)(DrawerController * __nonnull, UIGestureRecognizer * __nonnull);

/// Sets a callback to be called to determine if a UIGestureRecognizer should recieve the given UITouch.
///
/// This block provides a way to allow a gesture to be recognized with custom logic. For example, you may have a certain part of your view that should accept a pan gesture recognizer to open the drawer, but not another a part. If you return YES, the gesture is recognized and the appropriate action is taken. This provides similar support to how Facebook allows you to pan on the background view of the main table view, but not the content itself. You can inspect the <code>openSide
/// </code> property of the <code>drawerController
/// </code> to determine the current state of the drawer, and apply the appropriate logic within your block.
///
/// Note that either <code>openDrawerGestureModeMask
/// </code> must contain <code>OpenDrawerGestureModeCustom
/// </code>, or <code>closeDrawerGestureModeMask
/// </code> must contain <code>CloseDrawerGestureModeCustom
/// </code> for this block to be consulted.
///
/// \param gestureShouldRecognizeTouchBlock A block object to be called to determine if the given <code>touch
/// </code> should be recognized by the given gesture.
@property (nonatomic, copy) BOOL (^ __nullable gestureShouldRecognizeTouchBlock)(DrawerController * __nonnull, UIGestureRecognizer * __nonnull, UITouch * __nonnull);
- (nullable instancetype)initWithCoder:(NSCoder * __nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;

/// Creates and initializes an DrawerController object with the specified center view controller, left drawer view controller, and right drawer view controller.
///
/// \param centerViewController The center view controller. This argument must not be <code>nil
/// </code>.
///
/// \param leftDrawerViewController The left drawer view controller.
///
/// \param rightDrawerViewController The right drawer controller.
///
/// \returns  The newly-initialized drawer container view controller.
- (nonnull instancetype)initWithCenterViewController:(UIViewController * __nonnull)centerViewController leftDrawerViewController:(UIViewController * __nullable)leftDrawerViewController rightDrawerViewController:(UIViewController * __nullable)rightDrawerViewController OBJC_DESIGNATED_INITIALIZER;

/// Creates and initializes an DrawerController object with the specified center view controller, left drawer view controller.
///
/// \param centerViewController The center view controller. This argument must not be <code>nil
/// </code>.
///
/// \param leftDrawerViewController The left drawer view controller.
///
/// \returns  The newly-initialized drawer container view controller.
- (nonnull instancetype)initWithCenterViewController:(UIViewController * __nonnull)centerViewController leftDrawerViewController:(UIViewController * __nullable)leftDrawerViewController;

/// Creates and initializes an DrawerController object with the specified center view controller, right drawer view controller.
///
/// \param centerViewController The center view controller. This argument must not be <code>nil
/// </code>.
///
/// \param rightDrawerViewController The right drawer controller.
///
/// \returns  The newly-initialized drawer container view controller.
- (nonnull instancetype)initWithCenterViewController:(UIViewController * __nonnull)centerViewController rightDrawerViewController:(UIViewController * __nullable)rightDrawerViewController;
- (void)encodeRestorableStateWithCoder:(NSCoder * __nonnull)coder;
- (void)decodeRestorableStateWithCoder:(NSCoder * __nonnull)coder;
- (UIViewController * __nullable)childViewControllerForStatusBarHidden;
- (UIViewController * __nullable)childViewControllerForStatusBarStyle;

/// Sets the maximum width of the left drawer view controller.
///
/// If the drawer is open, and <code>animated
/// </code> is YES, it will animate the drawer frame as well as adjust the center view controller. If the drawer is not open, this change will take place immediately.
///
/// \param width The new width of left drawer view controller. This must be greater than zero.
///
/// \param animated Determines whether the drawer should be adjusted with an animation.
///
/// \param completion The block called when the animation is finished.
- (void)setMaximumLeftDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void (^ __nullable)(BOOL))completion;

/// Sets the maximum width of the right drawer view controller.
///
/// If the drawer is open, and <code>animated
/// </code> is YES, it will animate the drawer frame as well as adjust the center view controller. If the drawer is not open, this change will take place immediately.
///
/// \param width The new width of right drawer view controller. This must be greater than zero.
///
/// \param animated Determines whether the drawer should be adjusted with an animation.
///
/// \param completion The block called when the animation is finished.
- (void)setMaximumRightDrawerWidth:(CGFloat)width animated:(BOOL)animated completion:(void (^ __nullable)(BOOL))completion;

/// Sets the new centerViewController.
///
/// This sets the view controller and will automatically adjust the frame based on the current state of the drawer controller. If <code>closeAnimated
/// </code> is YES, it will immediately change the center view controller, and close the drawer from its current position.
///
/// \param centerViewController The new <code>centerViewController
/// </code>.
///
/// \param closeAnimated Determines whether the drawer should be closed with an animation.
///
/// \param completion The block called when the animation is finsihed.
- (void)setCenterViewController:(UIViewController * __nonnull)newCenterViewController withCloseAnimation:(BOOL)animated completion:(void (^ __nullable)(BOOL))completion;

/// Sets the new centerViewController.
///
/// This sets the view controller and will automatically adjust the frame based on the current state of the drawer controller. If <code>closeFullAnimated
/// </code> is YES, the current center view controller will animate off the screen, the new center view controller will then be set, followed by the drawer closing across the full width of the screen.
///
/// \param newCenterViewController The new <code>centerViewController
/// </code>.
///
/// \param fullCloseAnimated Determines whether the drawer should be closed with an animation.
///
/// \param completion The block called when the animation is finsihed.
- (void)setCenterViewController:(UIViewController * __nonnull)newCenterViewController withFullCloseAnimation:(BOOL)animated completion:(void (^ __nullable)(BOOL))completion;
- (void)toggleLeftDrawerSideAnimated:(BOOL)animated completion:(void (^ __nullable)(BOOL))completion;
- (void)toggleRightDrawerSideAnimated:(BOOL)animated completion:(void (^ __nullable)(BOOL))completion;

/// Closes the open drawer.
///
/// \param animated Determines whether the drawer side should be closed animated
///
/// \param completion The block that is called when the close is complete
- (void)closeDrawerAnimated:(BOOL)animated completion:(void (^ __nullable)(BOOL))completion;
- (void)viewDidLoad;
- (void)viewWillAppear:(BOOL)animated;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewWillDisappear:(BOOL)animated;
- (void)viewDidDisappear:(BOOL)animated;
- (BOOL)shouldAutomaticallyForwardAppearanceMethods;
- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator> __nonnull)coordinator;
- (BOOL)gestureRecognizer:(UIGestureRecognizer * __nonnull)gestureRecognizer shouldReceiveTouch:(UITouch * __nonnull)touch;
@end


@interface UIViewController (SWIFT_EXTENSION(DrawerController))
@property (nonatomic, readonly, strong) DrawerController * __nullable evo_drawerController;
@property (nonatomic, readonly) CGRect evo_visibleDrawerFrame;
@end

#pragma clang diagnostic pop
